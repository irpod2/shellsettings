# Common shell file to source

function cur_git_branch {
  local git_branch
  if [ -n "$ZSH_VERSION" ]; then
    # assume Zsh
    local ref=$(git symbolic-ref HEAD 2> /dev/null) || ref="$(git rev-parse HEAD 2> /dev/null)"
    git_branch=$(basename $ref)
  elif [ -n "$BASH_VERSION" ]; then
    # assume Bash
    git_branch=$(__git_ps1 "%s")
  fi
  echo -n $git_branch
}

function source_custom_file {
  local local_file=~/.customrc
  if [ -f $local_file ]; then
    source $local_file
  else
    echo "Warning: Can't find local file: $local_file"
  fi
}

if [ -n "$ZSH_VERSION" ]; then
  # assume Zsh
  export RPROMPT='%{%f%F{red}%}${DISPLAY_RPROMPT_COMMAND_TIME} %{%f%F{magenta}%}$(date +%H:%M:%S)%{%f%F{default}%}'

  strlen () {
    local input_str=$1
    local invisible='%([BSUbfksu]|([FK]|){*})'
    local LEN=${#${(S%%)input_str//$~invisible/}}
    echo -n $LEN
  }

  export DISPLAY_RPROMPT_COMMAND_TIME=''

  # Necessary for $EPOCHSECONDS, the UNIX time.
  zmodload zsh/datetime

  josh_last=()
  precmd () {
    if [[ -z $josh_last ]]; then
      return
    fi

    local difference=$(( $EPOCHSECONDS - $josh_last ))
    local base_rprompt='%{%f%F{magenta}%}$(date +%H:%M:%S)%{%f%F{default}%}'
    if [[ $difference -gt 10 ]]; then
      DISPLAY_RPROMPT_COMMAND_TIME="∆${difference}s"
    else
      DISPLAY_RPROMPT_COMMAND_TIME=''
    fi

    josh_last=()
  }

  preexec () {
    ####
    josh_last=$EPOCHSECONDS
    ####

    local cur_time=$(date +"%H:%M:%S•")
    local len_right=$(strlen $cur_time)
    local len_r_prompt=$(strlen $RPROMPT)
    local right_start=$(($COLUMNS - $len_right - 1))

    local len_cmd=$(strlen $@)
    local cleaned_prompt='$(sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" <<< ${(S%%)PROMPT//$~invisible/})'
    local len_prompt=$(strlen $cleaned_prompt)
    local len_left=$(($len_cmd + $len_prompt))

    local right_cur_time="\033[${right_start}C ${cur_time}"

    if [ $len_left -gt $right_start ]; then
      echo -e "${fg[cyan]}${right_cur_time}${fg[default]}"
    else
      # move up one line
      echo -e "\033[1A${fg[cyan]}${right_cur_time}${fg[default]}"
    fi
  }

  alias G="| grep "
  alias V="| grep -v "
  alias L="ls -hal "

  alias src='source ~/.zshrc'
elif [ -n "$BASH_VERSION" ]; then
  # assume Bash

  # Some fun colors for the terminal
  # Regular Colors
  Black='\[\e[0;30m\]'        # Black
  Red='\[\e[0;31m\]'          # Red
  Green='\[\e[0;32m\]'        # Green
  Yellow='\[\e[0;33m\]'       # Yellow
  Blue='\[\e[0;34m\]'         # Blue
  Purple='\[\e[0;35m\]'       # Purple
  Cyan='\[\e[0;36m\]'         # Cyan
  White='\[\e[0;37m\]'        # White

  #. /usr/local/git/contrib/completion/git-completion.bash
  PS1="$Red#\# $Green\t $Blue\w$Yellow\$(__git_ps1)$Cyan\$$White "

  alias src='source ~/.bashrc'
fi

alias gsync='git submodule sync'
alias gpush='git push josh $(cur_git_branch)'
alias gsu='git submodule update --init --recursive'
alias gs='git status'
alias gss='git stash save'
alias gsl='git stash list'
alias gsp='git stash pop'
alias gsd='git stash drop'
alias gco='git checkout'
alias gp='git pull --ff-only upstream $(cur_git_branch)'
alias gpr='git pull --rebase upstream $(cur_git_branch)'
alias gd='git diff'
alias gdc='git diff --cached'
alias gb='git branch'
alias gcm='git commit -m'
alias gl='git log --date=short --format="%Cred%h %Cgreen%ad %<(16,trunc)%Cblue%an %Creset%s %Cred"'

export VISUAL=vim
export EDITOR="$VISUAL"

# Custom stuff
source_custom_file
